数据库服务端与数据库客户端（系统端），都是通过连接池建立联系的。这样的好处是就可以并发处理，而且避免频繁的创建连接和销毁连接，使用连接池提高性能；
客户端常用的连接池：DBCP, C3P0, Druid等；


Mysql数据库服务端的架构设计
1 启动一个mysql就会启动一个进程，并且会有连接池等待客户端进行连接；
2 服务端连接池中的某个连接接收到一个网络请求后，通过线程从连接中提取出请求信息；
3 提取出的信息（sql语句或者存储过程）首先交由SQL接口去执行，SQL接口是MYSQL内部的一个组件，它是一套执行SQL语句的接口，专门用于执行发送给MYSQL的增删改查的SQL语句；
4 SQL接口会把SQL语句传递给查询解析器进行SQL解析；也就是在查询解析器里面，sql语句按照既定的sql语法，拆解成语法树；
5 接着通过查询优化器在语法树上选择一条最优的查询路径；通俗点说就是按照什么顺序去执行sql，在复杂查询语句里面非常有用；
6 执行计划交给执行器，执行器调用存储引擎的接口一步一步的按计划执行；
7 最后返回处理结果；


InnoDB存储引擎架构设计
执行器调用存储引擎接口执行执行计划，存储引擎内部是如何处理执行计划的？
以 update user set name=xxx where id = 1 为例进行说明
1 首先有个Buffer fool（缓冲池）的概念，存储引擎对数据的增删改查都是基于缓冲池操作的；如果需要更新的数据不在缓冲池，就会去磁盘文件中读取到缓冲池；
2 更新数据的时候，会对该条数据加独占锁避免并发事物引起的脏写；
3 把该条数据的旧值写入undo日志文件，便于回滚；
4 把这条数据在内存中的name修改为xxx，此时此刻这条数据是脏数据，因为内存中的数据与磁盘上的数据不一致；
5 把对这条数据的修改记录写入一个名为redo log buffer的缓冲池，redo日志是用来记录对数据做了什么修改，便于在mysql宕机时重做数据；【此时mysql服务宕机并不要紧，因为事物还没有提交，redo log还停留在内存中的缓冲池，而且磁盘文件的数据还没改变】
6 提交事物，就会根据策略把redo log buffer中的redo log刷入磁盘文件；配置项：innodb_flush_log_at_trx_commit；有三个配置值：①值为0；表示提交事物，redo log日志并不会刷入redo log磁盘文件，这种策略下事物提交后，mysql宕机会出现数据不一致的情况；②值为1；表示提交事物，redo log buffer中的日志必须刷入redo log磁盘文件；这种策略下事物提交后，msyql宕机了，就算修改后的数据未刷入磁盘中但有redo log，因此可以对数据进行重做恢复；③值为2；表示提交事物，redo log buffer中的日志写入对应的os cache缓存中，而不是磁盘文件；这种策略下如果机器宕机就会发生跟策略1一样的情况；
7 提交事物前，就会根据策略把此次更新的binlog日志写入磁盘文件；配置项：sync_binlog；有两个配置值：①默认值为0；binlog日志刷入os cache内存缓存；②值为1；binlog日志刷入binlog磁盘文件；【redo log和binlog有什么区别？ Redo log是存储引擎级别的一个日志文件，记录的内容更偏向于物理性质的重做日志，而binlog日志是mysql级别的一个日志文件，记录的内容更偏向于逻辑性的日志；】
8 完成最终的事物提交，把本次更新对应的binlog文件名称和这次更新的binlog日志在文件里的位置，都写入到redo log文件里面，同时在后面加上commit标记；事物提交完成；【commit标记意味着redo log和binlog文件都刷盘了，此时发生机器宕机都无所谓】
https://www.processon.com/view/link/611a500f637689241eec90cb

BufferPool是什么？
BufferPool是数据库的一个内存组件，里面缓存了磁盘上的真实数据；Java系统对数据库的增删改查实际上就是对这个内存中的缓存数据进行的。

如何配置BufferPool的大小？
Innodb_buffer_pool_size=137072
默认为128M大小，配置的单位为KB；如果数据库是16U32G，建议配置成2G

BufferPool里面的数据结构是怎么样的？
Mysql把实际的一行数据写在磁盘文件里面，多行数据在一起组成了数据页，这个数据页就是msyql在磁盘文件里面的最小单位，一个数据页大小默认是16KB；
如果说我们要更新一行数据，就会首先找到这行数据所在的数据页，然后把数据页加载到Buffer Pool中变成缓存页，然后基于缓存页对这条数据进行修改；所以BufferPool中的数据结构是缓存页，它的大小也是16KB；
每个缓存页都对应一个描述信息，描述信息主要是用来描述缓存页的基本信息，比如该数据页所属的表空间，数据页的编号，这个缓存页在Buffer Pool中的地址以及其他的东西；在Buffer Pool中每个缓存页的描述信息放在最前面，而缓存页则放在最后面；每个描述信息占据缓存页大小的5%，也就是800个字节，所以设置了128m用来存放缓存页，实际还会占据其他的额外空间用于存放描述信息。

注意：数据库启动的时候，首先申请一块空闲的内存区域作为BufferPool的内存区域；数据库会按照默认的缓存页大小16KB以及对应的800个字节左右的描述信息大小，在BufferPool中划分出一个个的缓存页和一个个的描述数据；默认是空闲的，等到进行增删改查时才会从磁盘中加载数据页到缓存页。

如何判断BufferPool中哪些缓存页是空闲的？
为了解决这个问题，数据库为BufferPool设计了free双向链表，这个free双向链表的节点值就是空闲缓存页对应的描述信息的地址，也就是说通过一个双向链表来记录哪些描述信息对应的缓存页是空闲的；free链表有一个特殊的节点就是基础节点，她会引用链表的头尾节点，同时还存储了free链表有多少个节点；当加载数据页到BuffePool中时，首先会去free链表中获取一个节点，这个节点就可以告诉bufferPool这个数据页放到哪个缓存页，他的额外数据放在哪个描述信息里面，然后这个节点从链表中移除掉；


如何判断某个数据页是否被缓存？
为了解决这个问题，数据库设计出数据页缓存哈希表来记录哪些数据页被缓存了。数据页缓存哈希表是一个key-value的哈希数据结构，key是表空间+数据页号，value是对应的缓存页地址；每次读取数据页的时候都会到该数据页缓存哈希表判断下，如果存在则直接拿到缓存页，如果不存在则走上面的逻辑，并且把执行后的结果写入该数据页缓存哈希表中；

脏数据的概念是什么？
bufferPool中缓存页内的数据被修改，但磁盘上的数据还是旧值，此时缓存页里面的数据就是脏数据，该缓存页就是脏页；

如何标记缓存页是脏页？
我们都知道，脏页通过IO线程异步刷入磁盘；那么数据库是如何标记脏页的？
数据库引入了flush链表，把修改过的缓存页的描述数据利用指针形成一个双向链表；也就是说，凡是被修改过的缓存页，对应的描述信息都会加入flush链表中，flush链表的基础节点引用了头尾节点，并且包含了链表中的节点数量。

缓存页被用完了怎么办？
bufferPool中的缓存页都是按照16K的大小来进行划分；随着数据库的运行，增删改查越来越多，free链表中的空闲缓存页总会用完的，针对这种情况数据库采用淘汰机制获取空闲缓存页；淘汰机制就是会把一些不常用的缓存页刷入磁盘后释放掉缓存页，该缓存页的描述信息加入free链表，然后供数据库加载新的数据页；

缓存页的淘汰机制是怎么样的？
数据库引入缓存命中率的概念；所谓的缓存命中率就是说这个这个缓存页在100次操作中被操作的次数，如果小于10次那么就可以认为是低命中率，否则就认为是高命中率；而淘汰机制自然就会淘汰缓存命中率的缓存页；

如何标记哪些缓存页命中率高，哪些缓存页命中率低？
数据库引入LRU链表（least recently used）标记缓存页的命中率。
当数据页被加载到缓存页的时候，从free链表中获取一个空闲的缓存页用于存放数据页，该缓存页的描述信息节点从free链表移除掉，然后加入lru链表的头部；也就是说非空闲的缓存页的描述数据节点都会在lru链表内部，而且刚加载的缓存页的描述数据存在lru链表的头部；另外，当lru链表中的任何一个节点的缓存页被查询或者修改，那么这个节点就会被移动到lru链表的头部；所以lru链表上的节点就是按照被访问的先后顺序进行链接在一起的；

Mysql的预读机制导致LRU链表在某种场景下会失效
所谓的预读机制就是读取某个数据页的同时会把这个数据页前后的数据页读取出来并放到缓存页；那么此时LRU链表的头部除了被访问的数据页，还有通过预读机制加载进来的缓存页，而LRU链表的尾部有可能就是被频繁访问的缓存页，正好缓存页被用完了，那么淘汰掉的缓存页就是被频繁访问的缓存页；所以预读机制就会导致LRU链表在特殊场景下失效；
另外全表扫描也会导致同样的问题。

Mysql何时触发预读？
1 如果顺序的访问了一个区里的多个数据页，访问的数据页的数量超过了参数innodb_read_ahead_threshold设置的值（默认56），就会触发预读；把下一个区中的所有数据页都会加载到缓存里面；
2 如果bufferPool里缓存了一个区里面的13个连续的的数据页，而且这些数据页都是被频繁的访问，那么就会触发预读，把这个区里面的其他数据页加载到缓存；这个是通过参数innodb_random_read_ahead设置，默认为off为关闭；

基于冷热数据分离的思想改进LRU链表
由于预读机制带来了很多问题，因此基于冷热数据分离的思想改进LRU链表。所谓的冷热数据分离是指把LRU链表拆分成两个部分，一部分是热数据，一部分是冷数据，这个冷热比例是由参数innodb_old_blocks_pct控制，默认为37，即冷数据占比37%；
数据页被首次加载到缓存页，会放置在冷数据链的头部；如果这个缓存页在参数innodb_old_blocks_time设置的时间之后再次被访问，那么就会移动到热数据链的头部，默认是1秒；
此时冷数据链中的缓存页都是通过预读机制或者全表扫描加载过来的数据页；

针对redis里面的冷热数据应该如何设计？
答：针对电商里面的热点商品，需要通过缓存预加载机制提前加载到内存中；

热数据链中的数据被访问之后是否会被移动到热数据链的头部？
答：为了减少移动节点带来的性能开销，mysql作了优化；规定热数据链表中头部四分之一的节点即使访问了也不会移动到链表头部，只有热数据链的后四分之三被访问了才会移动到链表的头部。

冷数据链表尾部的缓存页什么时候会被刷盘？
1 存在一个定时的后台线程，每隔一段时间就会把LRU链表的冷数据区域的尾部的缓存页刷入磁盘，然后清空缓存页，并把他们加到free链表中供其他数据页使用；
2 此后台线程还会把flush链表中的缓存页都刷入磁盘，然后清空这部分缓存页，从flush和lru链表中删除，并把他们加入到free链表中；

所以说，如果在这种设计策略之下，缓存页还是不够用怎么办？
答：会把LRU链表的冷数据区域的尾节点的缓存页强制刷盘并清空，然后再找到需要的数据页加载到缓存页中。【思考：为了避免这种情况的发生，mysql内核参数应该如何优化？】

实际生产优化案例：
1 为了提高数据库的并发能力，当数据库内存大于2G时，可以通过参数innodb_buffer_pool_instance设置bufferPool的数量；一般bufferPool大小为2G，可以通过内存/2G确定参数的值；
2 通过chunk机制实现数据库运行期间动态的调整buffer pool的大小；也就是说，mysql通过优化bufferPool的设置机制，把bufferPool由一整块内存拆分成一个一个chunk组成，每个chunk是128M，每个bufferPool的chunk共享一个free链表、flush链表和LRU链表；

生产实际设置经验：1 BufferPool的总大小为机器内存的50%-60%；2 BufferPool的总大小等于chunk的大小*buffer pool的数量的倍数；【show engine innodb status命令查看数据库状况，可以看到数据库的内存信息】

数据库为什么要引入数据页的概念？
首先，如果所有的CRUD都是基于磁盘的随机读写进行，那么数据库的性能极差，无法抗住大并发，所以需要基于内存来操作；既然基于内存操作，那么必然需要把数据加载到内存再执行操作，如果基于每条数据来操作，那么磁盘的IO就会很频繁，性能同样也有影响，因此mysql提出数据页的概念，把一批数据行组成一个数据页，加载的最小单元从数据行变成数据页，将会减少磁盘的IO，提高性能；

数据行是如何存储在数据页上的？
首先，在创建表的时候可以指定行存储的格式，默认为compact，这种格式下每行的数据存储类似下面这种格式：
变长字段的长度列表，null值列表，数据头，column1的值，column2的值，columnn的值…

变长字段的长度列表用于存放字段类型为varchar类型，也就是实际存储时字段的值长度不固定；存储的是十六进制的实际长度，如果有多个变长字段，那么需要逆序存储；比如
Varchar(10) Varchar(6) Varchar(10) Varchar(10)   char
China      is       beautify   country      。
存储在磁盘上就是如下格式：
0x07 ox8 ox02 ox5 null值类表 数据头 。
之所以把变成字段的长度单独提取出来存储时为了在读取时能完整的读到一行数据，不然无法读取准确的行数据；

Null值列表用于表示哪些字段是null哪些字段不是null，采用的是bit位进行标识；首先根据DDL语言判断有几个字段是允许为null的，如果此行数据中允许为null的字段值为null，那么标识位就是1，否则就是0，同样采用逆序的方式存储表示；比如
Name vahrchar(10) not null,
Age varchar(10),
Gender char(1),
School varchar(15)
以上四个字段，name不为null，其他三个字段均允许为null，同时gender为定长字段，其他三个为变长字段，所以针对lisi null G xx_school这行数据的存储格式是：
0x09 0x04 00000010 头信息 column1=value1 column2=value2…

数据头是用来描述这行数据的，是40个bit位；
第一位和第二位是预留位，无任何意义；
第三位是delete_mask，它标识这行数据是否被删除；
第四位是min_rec_mask，它标识B+树里每一层的非叶子节点的最小值都有这个标记
第5-8位是n_owned
第9-21位是heap_no，它标识当前这行数据在记录堆里的位置；
第22-24位是record_type，它表示这行数据的类型；0代表普通类型，1代表B+树非叶子节点，2代表最小值数据，3代表最大值数据；
第25-40位是next_record，它是指向下一条数据的指针；

行数据实际存储时的几个隐藏字段
1 DB_ROW_ID 数据库内部给这条数据加的唯一标识，如果一个表未指定主键或者唯一索引，就会把这个值作为主键ID；
2 DB_TRX_ID 这个是事物ID，表明是哪个事物操作的；
3 DB_ROLL_PTR 这个是回滚指针，用来进行事物回滚的；
另外，所有的数据存储在磁盘上都是按照数据库字符集编码后的格式存储；一条完整的数据如下所示：
0x09 0x04 00000010 00…00 00000000094C(DB_ROW_ID) 00000000032D(DB_TRX_ID) EA000000078E(DB_ROLL_PTR) 61616 6232646 4645132465

行溢出的问题
如果一行数据的某个字段特别大，比如类型为text或者blob类型，那么16KB的数据页可能存储不下，这个时候就需要跨页存储了，也就是行溢出的问题；

数据页长啥样？
一个数据页包含如下几个部分：
1 文件头；占据38个字节
2 数据页头；占据56个字节
3 最大记录/最小记录；占据26个字节
4 多个数据行；不固定；
5 空闲区域；不固定；
6 数据页目录；不固定；
7 文件尾部；占据8个字节；


数据页插入一行数据的过程？
执行器调用存储引擎的接口插入数据的过程：
1 假如此时是一个干净的数据库，那么bufferPool中无缓存页；
2 从数据库磁盘加载一个数据页到bufferPool中变成缓存页；【走free链表，放到lru链表】 
3 一行数据按照数据行的格式存放在缓存页中；【加redolog和binlog日志，同时描述数据节点加到flush链表】
4 后台线程通过异步的方式把flush链表中的脏页刷入磁盘；

表空间，数据区的概念？
所谓的表空间是一个物理上的概念，对应到逻辑层就是一个表结构，在磁盘上就是“表名.ibd”磁盘文件；由于数据页的大小是16KB，不便于管理，所以把连续的64个数据页组成一个数据区（extent）,这样来算就是64*16=1mb大小，由于数据区也很多所以把256个数据区划分为一组；
所以简单记忆就是：一个表空间，管理这个多组数据区，一组数据区是256个数据区组成，一个数据区是连续的64个数据页组成，一个数据页的大小是16KB；

注意：第一组的第一个数据区的头3个数据页都是固定的，用于存放描述性的信息；其他组的第一个数据区的头两个数据页也是存放特殊信息的；

获取数据页的时候是如何从磁盘中获取的？【疑问？】
通过随机读写的方式从表空间中获取一个数据页；【磁盘随机读写】
磁盘随机读写的性能比较差，所以把数据页读到内存后都是基于缓存页来操作的；磁盘随机读写的两个性能指标：IOPS和响应延迟：
1 IOPS 是说底层的存储系统每秒可以执行多少次磁盘读写操作；这对性能影响很大，IOPS越高性能越好，数据库支持的并发越高；
2 响应延迟 就是每个sql执行的响应延迟；响应延迟越小越好；

Redo log和binlog日志走的是磁盘的顺序读写；所谓的顺序读写就是一直在某个文件的末尾追加数据；顺序读写的性能很高，好比在内存那种的读写一样；所以这里关注的性能指标是吞吐量，即每秒可以写多少数据到磁盘；

数据库基于Linux操作系统对磁盘文件进行读写；
RAID技术是一个多磁盘冗余阵列技术，可以管理多块磁盘，并且可以把一份数据存储在多块磁盘上，保证数据不会丢失；

数据库报异常：“too many connections”的原因？
MySQL数据库在my.cnf配置文件配置了最大连接数max_connections为800；但实际连接数为214就报too many connections错误，无法继续创建连接与系统交互，这个本质原因是linux操作系统把进程可以打开的文件句柄数限制在1024了；具体怎么解决？
MySQL内部源码根据计算公式，在文件句柄数限制在1024时最大连接数为214，所以核心就是修改这个文件句柄数；可以通过ulimit命令设置每个进程被限制使用的资源量；ulimit –HSn 65535 设置文件句柄数量为65535，通过命令cat /etc/security/limits.conf cat /etc/rc.local确保修改落实到配置里面；

Redolog日志的一些问题
Redolog日志记录什么？
Redolog日志是用来记录某个事物对缓存页中某条数据的修改













